回合流程应该通过事件驱动

事件在本地进行条件校验后显示为可发生的

如，回合结束动作、手牌发动动作、复活动作等。

动作被发送到服务器进行校验，判断该动作是否可行。

校验通过后，同时向其余client推送事件帧（包括当前将要执行的效果栈）

然后执行询问 askClient，是否对该动作进行回应，例如发动效果，不发动效果等。

askClient将被ask的用户置为asked，此时可以发动满足条件的响应效果。

为ask设计倒计时，如果当前用户没有可发动的效果，则倒计时5s或者用户主动结束自己的ask状态。（目前不实现）

该过程可以描述为

1、 当前回合客户端 → 宣告发动动作 → 服务器
2、 服务器校验动作是否合法
3、 服务器 → 宣告帧 → 所有客户端
4、 客户端 呈现 宣告帧
5、 服务器 → ask宣告帧 → 客户端（按编号轮流发送）
如果此时没有客户端打算发动效果： 
6、 客户端 → 宣告帧 → 客户端（依次）
7、 服务器 → 结果帧 → 客户端 （指玩家A不响应动作这一结果）
如果有一个客户端打算发动效果：
6、 客户端 → 宣告动作 → 服务器
7、 服务器 → 新宣告帧 → 客户端 （宣告要应对该效果启动自己的效果，然后再接着ask）

8、 服务器依次计算结果
9、 发送事件栈给

# 帧
从服务端发送到用户端，用于更新客户端的本地信息的数据包

## 宣告帧
宣告效果的发动、回合的结束、复活动作（复活动作应该直接发送结果帧）。

一切动作在经服务器检验为可发动后，都需要向其他用户发送该效果发动的信息。

此时进行效果的cost的处理，并声明效果的对象（如果有）

根据宣告帧，本地更新展示界面。

服务器检查是否因为cost而诱发了必发效果，如果有，加入必发效果容器内，等待所有效果栈处理完后，进行下一轮处理

效果的发动、回合的结束该动作发送完宣告帧后，需要经过响应环节。

如果是复活动作，现阶段可以设置为不可响应环节，只提供确认时间，或者直接结束确认。（目前都响应吧

## 结果帧

处理结果后产生的帧。

响应阶段全部结束后，执行结果处理。

从效果栈中取效果，服务器依次处理效果。

服务器将处理完的效果推送给客户端。

结果帧不需要确认。

响应是通过是否有响应环节来实现的。

处理完效果

# 响应
以下动作发生后，应该进行响应：

效果的处理完成后（造成了结果）。

卡的效果的发动时。

若有响应，则向服务器推送新的响应发动，服务器校验可行后，向所有用户push结果


# 发动

效果的发动是异步的。
当校验结果为true时，
开启异步线程发送宣告帧，
发送结束后异步线程结束。（如果失败呢？现在不考虑）
异步线程中，先推送一个效果发动的帧，
然后确认cost是否引发卡牌自身的副作用，例如，时间风暴将自己的可发动效果加入到sideEffect当中。
进入询问环节。
并返回200

# 事件Event
事件属于抽象的行为结果
例如，骰子摇出6、抽了两张牌等等
例如一个效果结算完成，相关的所有事件都会通过unUpdateEvenList然后推送到客户端进行结算。
随后将事件添加到evenList当中。
evenList表示在一组连锁上所有发生的事件。
在takeEffect时，意味着由这些事件可引发的效果已经不存在了，因此会清空evenList
unUpdateEvenList在服务中堆积的新事件。通常，一个效果的事件是复合的。

# takeEffect
一个栈的效果全部处理完后，会进行asking
如果asking没有应答，就应该清除掉event list，
随后推送askingEndMessage，表明当前所有效果链都结算完毕
效果一定是调用游戏的原子性操作进行的。
应该在每一个游戏的原子性动作上校验是否已经游戏结束。
# Message
应答消息 通过id标识
两端通过id 和map来维护一个待应答消息
通过listener的阻塞方法进行等待。
updateMessage 是不是相当于event？
骰子应该是一个事件 notify，触发某个回调事件，但是算成event如何？
update应该定义为对view有变更，且由下一次view才能改变的东西的话，骰子结果就不算是了
## 
pushUpdateMessage
// 在一定时间内尝试推送一个同一编号的消息
如果超过一定时长没有得到回应，则push第二次，
尝试数次后，则无视此次的推送失败。
remove掉本地的listener
如果对方返回错误，例如状态不一致的错误，则通过push全景View覆盖对方的本地view来保证状态的一致。
# 设计

目前，服务端和客户端的程序并不分离，这意味着一个程序既能够当作客户端，也可能同时作为一场游戏的服务器。

客户端通过创建大厅，在客户端内部开设服务器。服务端和客户端之间通过WebSocket进行通信。

## 客户端
客户端一般不持有完整的游戏信息。即无法获知对方的手牌实际内容，拥有的只有一个视图（view）

客户端做操作时，会做自己的行为合法性校验，这是为了在客户端上显示当前支持哪些动作。

客户端不做游戏的具体逻辑处理。所有的更新都通过被动接受服务端的更新推送（push）完成。

## 服务端
服务端目前没有和客户端分离。客户端的动作将在服务端上进行内部校验，换句话说服务端不信任客户端的请求是否合法。

有一种设计是端对端的设计，即本地客户端进行游戏逻辑实现，再将逻辑结果（经由服务器路由）推送给其他客户端。

其他客户端无条件接受对方客户端的处理结果。这样的好处是服务端的工作非常轻松，仅仅转发指令就行，

但效果的逻辑全仰赖一方客户端的正确性，这种设计意味着客户端作弊的可能性很高。

目前的设计中，服务器检验和处理游戏逻辑，即有条件受理客户端的请求，客户端无条件接受服务器推送结果。

# 游戏状态更新方式-Event Driven

回合流程通过事务进行驱动，也即是说，游戏的状态不是按秒刷新的，如果没有新的事务发生，服务器和客户端的状态都不会变化。

新的事务在服务端进行合法性校验，当它被校验通过，则转换成"即成结果"推送到客户端。

目前，这类更新通过特殊的 UndateMessage实现。该Message携带一组Event。

客户端无条件接受服务端的更新指令。进行客户端状态的更新。

此时，由于场上的状态发生改变，可能有新的动作满足了发动条件，玩家可见的卡片将在本地客户端进行一次条件校验，

若通过，则可以在用户界面上显示为"可发动的"


# 消息Message
消息是客户端和服务端之间进行沟通使用的通信载体。两边交换的信息我们统称为一个Message（这是一个POJO）。

通信过程大体如下：

1. 服务端 ← A客户端 ：宣告消息

2. 服务端 校验

3. 服务端 →所有客户端 ： 推送消息


## 宣告消息
这类消息由客户端发送给服务端。代表着持有优先权的玩家宣告效果的发动、回合的结束、复活动作等等。

宣告帧由客户端发送给客户端，通常意味着：我要执行xxxxx了，服务器你看我这个动作合不合法。

一切动作在经服务器检验为可发动后，这个"宣告"，就转换成了合法的"推送"，其他客户端玩家就能看到这个动作的发生。

## 推送消息

事件被验证为合法后，服务器会向各个客户端同步更新状态。

推送帧代表着新的动作或者处理结果的发生，例如，有玩家声明他要发动了新的卡（有玩家在场地上拍出一张新的shoot牌，但没结算），

有一张卡的效果刚刚完成了结算，对游戏状态产生了影响（shoot牌打死了一个人）

# 询问响应
部分事件发生后，还需要由客户端进行事件响应。

例如：效果的处理完成后（造成了结果事件，如效果处理时投出了骰子，结果为6，或者发生了弃牌）。

或者是宣言即将结束这个回合的某个阶段。

在现实中，是由触发事件动作的玩家的右手边玩家开始询问是否针对该事件表态，

而在游戏中，则是由该名玩家开始，向下一名玩家处依次询问（ask）。

一些回合外能够发动的效果，都是在这个ask环节发动的。

如果不考虑客户端的宣告被服务器否决的情况，这类情况下顺利的流程是


1. 服务端 ← A客户端 ：宣告消息

2. 服务端 校验

3. 服务端 → 所有客户端：推送消息

—————下面的过程将循环，直到响应环节结束———————

4. 服务端 → 某一个客户端: 询问响应

5. 服务端 ← 客户端：应答消息

————————————————————————————
## ask环节开始
当触发需要响应的事件之后，ask环节就开始了。

我们把触发事件的一方称为askingPlayer，受询问的玩家称为askedPlayer

这个过程可以视为，玩家做了一个动作，他对剩余的玩家依次询问："你有意见吗？"

询问有两种应答方式，即通过(请自便吧)，或者发动新的效果(在当前的条件下，我也有效果可以发动)。 

后者又称为"连锁"。 当应答结束后，askedPlayer指向他的下一个顺位的玩家

在响应过程中，每当新的卡的效果发动，则都会随之触发一次新的ask过程，

由于新的ask开始，asking玩家会选定为产生应答动作的玩家。

ask环节有三种充分的触发条件，一种是效果栈有效果添加，则一定会引发ask，

一种是效果结算后evenList不为空

## ask环节终止
由于玩家连接成一个环形，asked玩家最终会和asking玩家重合，当重合时，没有新的效果被发动时，ask环节终止

若有响应，则向服务器推送新的响应发动，服务器校验可行后，向所有用户推送一个新的ask事件

ask环节终止时，会发生一次takeEffect，将堆积下来的效果事件按后发先至的顺序对游戏产生影响。

# 效果
## 发动
客户端向服务器发送发动某张卡效果的消息。这是一个宣告消息。

当效果在服务器端校验结果为合法时，效果被添加到效果栈EffectChain当中。

随后开始ask环节。

### 发动条件

大部分效果的发动都需要在本回合的出牌阶段进行。

少量卡能够针对其他卡的动作做出反应，但这种反应不是即刻就能做出的，需要等待这个动作的询问环节开始，

并且询问对象轮到自己时，才可以发动卡的效果。

## 结算 takeEffect
takeEffect即效果结算环节，该环节分为四个步骤，

第一，清空事件列表，第二，清空效果栈，第三，结算这个ask过程中弃掉的牌是否包含通过弃牌能够发动的效果，第四步，询问是否响应。

### 清空事件记录
在ask环节结束时，一方面会清空evenList，这是因为如果evenList如果还能诱发新的效果，ask环节就不会结束，

反之，evenList中所有的事件都没有保留的价值了。

### 清空效果栈
清理完成后，会对效果栈进行清算。

每个效果结算后，效果从栈顶移除，并将产生的事件新增到evenList和unUpdateEvent当中。

### 墓地必发效果结算
效果栈清空后，随后检查由于一连串效果送去墓地的卡片是否有能够触发的效果（时间风暴）

### ask环节
最后检查EvenList和EffectChain是否非空，如果全为空，则结束结算，若否，则从回合玩家的位置开始再次开始一轮询问

# 事件Event
事件属于抽象的行为结果。

例如，骰子摇出6、抽了两张牌，回合结束等等，这都可能是某些动作产生的结果。

他们可能是独立的，也可能是几个事件都是同一个效果的衍生结果。

一个效果结算完成，相关的所有事件都会推送到客户端进行结算。目前设计上是通过pushUnUndateEvent这个方法实现的。

对于立即结算效果的动作而言，动作本身不需要经过对方同意就能立刻执行，换言之不可能受到干涉

也就是说某些动作不存在"发动 - 发动确认 - 执行 - 结果确认"这样的过程。

而是"执行 - 结果确认"

这和游戏王不同，游戏王如果在己方宣告战斗阶段结束时，对方玩家发动了针对这个时间点才能发动的效果，

那么战斗阶段的结束动作无效，等对方效果处理完成后，你可以选择接着进行战斗阶段，或者重试结束这个阶段。

但目前没有计划实现这样的功能。

举个例子，当前结束出牌阶段的动作，一经宣告且校验通过，就会将结果推送到客户端，而不存在回卷（rollback）的可能

# 设计概念

## eventList
eventList表示在一组连锁上所有发生的事件。

在takeEffect时，意味着由这些事件可引发的效果已经不存在了，因此会清空evenList

## unUnpdateEventlist
另一个列表unUpdateEvenList保存在效果结算过程中堆积的新事件。通常，一个效果的事件是复合的。

这意味着他有多个结果，我们通常希望这些结果在一次推送过程中一起被更新在客户端上，而不是一个event推送一次，

这样看起来效果是割裂的。

## tempGraveyard 
一组连锁上即将被送去墓地的卡片。如，发动完效果的卡片，以及被效果弃置、被cost弃置的卡片。

# todo
// 在一定时间内尝试推送一个同一编号的消息
如果超过一定时长没有得到回应，则push第二次，
尝试数次后，则无视此次的推送失败。
remove掉本地的listener
如果对方返回错误，例如状态不一致的错误，则通过push全景View覆盖对方的本地view来保证状态的一致。

# 重构
game在目前的设计中，既充当handle操作Player的媒介
又是底层的一些原子性操作的载体。
理论上，game承载着维护游戏的主要信息，参与方，当前回合主、询问等诸多信息的任务，
负责容纳没有被推送出去的Event，
各个行为首先经过player 再转发至 roleCard，是为了使得role能够触发对应的回调。因为角色的不同，造成实际执行行为的不同。
底层经过game，是为了让game能够将该事件增加到“未推送事件”的列表。
我们以一个revive事件为例，
目前实际上是 handle → game.revive1 → A player.reviveB →  roleCard.reviveB → B player.awaken → B roleCard.awaken → game.awaken

计划中应该设计成这样：
handle → controller.revive A B→ 分发给Player → A player.reviveB → roleCard.reviveB → B player.awaken → B roleCard.awaken →  触发被动
                                                                    ↓      ↓                                ↓
                                                            game.discard  game.revive                game.awaken
                                                                    ↓      ↓                                ↓
                                                          PlayerA.discard                         B player.setStatus(LIVE)
                                                          
                                                          
                                                          
player 的所有操作都不操作自身。而是代理到role当中， role的行为是game 的原子性事件的 拼合